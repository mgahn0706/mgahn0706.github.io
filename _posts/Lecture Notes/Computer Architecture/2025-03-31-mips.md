---  
tags:  
  - architecture  
  - isa  
  - mips  
  - instruction  
share: "true"  
github_title: 2025-03-31-mips  
title: 3. MIPS  
date: 2025-03-31  
categories:  
  - Lecture Notes  
  - Computer Architecture  
---  
# Now we are going to study MIPS specifically!  
  
## Data Format  
  
Most things are 32 bits!  
  
- ëª…ë ¹ì–´ì™€ ë°ì´í„° ì£¼ì†Œ  
- signed, unsigned integer  
  
Floating Point Number (ë””ì‹œì„¤ ON)  
  
$$ (-1)^S \times (M+1)\times2^e $$  
  
---  
  
### Big Endian vs Little Endian  
  
ì˜ˆë¥¼ ë“¤ì–´ 4 byteì˜ ì •ìˆ˜ 0x12345678ë¥¼ ì €ì¥í•œë‹¤ê³  í•˜ì.  
  
Big endianì€ í•˜ë‚˜ì˜ 32ë¹„íŠ¸ ì €ì¥ì†Œì— 0x12, 0x34 â€¦ ìˆœìœ¼ë¡œ ì €ì¥ëœë‹¤.  
  
Little endianì€ í•˜ë‚˜ì˜ ì €ì¥ì†Œì— 0x78, 0x56â€¦ìœ¼ë¡œ ì €ì¥ëœë‹¤. ì¦‰, Big endianê³¼ little endianëª¨ë‘ 1byte ë‹¨ìœ„ë¡œ ë‚˜ëˆ ì„œ ì €ì¥í•˜ë‚˜ big endianì€ MSBìª½ ì¡°ê°ì„ ë¨¼ì €(ì£¼ì†Œê°€ ì‘ì€ ê³³ì—), little endianì€ LSBìª½ ì¡°ê°ì„ ë¨¼ì €(ì£¼ì†Œê°€ ì‘ì€ ê³³ì—) ë„£ëŠ”ë‹¤.  
  
- Big Endian (MIPS)  
    - í¬ê¸° ë¹„êµì— ìœ ë¦¬  
    - sign ì—¬ë¶€ íŒë‹¨ì— ìœ ë¦¬  
    - human-friendlyí•¨. 4byteë¥¼ ì ì ˆíˆ ìë¥´ê¸°ë§Œ í•˜ë©´ ì½ëŠ” ìˆœì„œê°€ ê·¸ëŒ€ë¡œì„  
- Little Endian (x86)  
    - í™€ìˆ˜ ì§ìˆ˜ íŒë‹¨ì— ìœ ë¦¬  
    - ì¶”ê°€ì ì¸ ì¡°ì‘ ì•ˆí•´ì¤˜ë„ ë¨  
  
---  
  
## Instruction Format  
  
3ê°€ì§€ê°€ ìˆë‹¤. `R-type` , `I-type` , and `J-type` .  
  
- 4-byte per insturction (CISCëŠ” ì•„ë‹Œê°€ë´„)  
- must be 4-byte aligned (2 LSB of PC should be 2â€™b00)  
  
â†’ í•˜ë“œì›¨ì–´ êµ¬ì¡° ë‹¨ìˆœí™”. fetchë¥¼ 4-byte ë‹¨ìœ„ë¡œ í•´ì„œ í•œë²ˆì— ê°€ì ¸ì˜¬ ìˆ˜ ìˆìŒ. ë©”ëª¨ë¦¬ ì ‘ê·¼ íšŸìˆ˜ ê°ì†Œ  
  
### 1. ALU Instructions (ADD, SUB, â€¦)  
  
(1)  
  
Assembly: `ADD rd rs rt` (R-type)  
  
Machine Code:  
  
`000000 sssss ttttt ddddd 00000 (ADD - 6 bits)`  
  
1. ì•ìë¦¬ 000000ìœ¼ë¡œ special instructionì„ì„ í™•ì¸  
2. GPR[rd] â† GRP[rt] + GPR[rs], PC â† PC + 4  
  
Exceptions on overflow.  
  
(2)  
  
Assembly: `ADDI rs rt immediate` (I-type)  
  
Machine code  
  
`ADDI rs rt (immediate 16-bit)`  
  
1. ADDI ë¼ëŠ” OPCODE ì¸ì‹  
2. immediateë¥¼ ê°€ì ¸ì™€ì„œ, sign-extension.  
3. GPR[rt] â† GRP[rs] + immediate  
  
â†’ There is no `SUB` in I-type ALU instruction! (compilerê°€ ë¶€í˜¸ë¥¼ ë°”ê¾¼ ê°’ì„ ADDIí•˜ë©´ ë˜ê¸° ë•Œë¬¸)  
  
### 2. Load Instructions  
  
Assembly: `LW rt offset base`  
  
Machine code:  
  
`LW (6-bit) base (5-bit) rt(5-bit) offset (16-bit)`  
  
- ì‹¤ì œ address ê³„ì‚°: GPR[base] + offset (sign extenstion)  
- GPR[rt] â† MEM[addr]  
- PC â† PC + 4  
  
### Data Alignment  
  
loadì™€ storeëŠ” WORD ë‹¨ìœ„ë¡œ ì´ë£¨ì–´ì§.  
  
ë§Œì•½ ë‘ wordì— ë”°ë¡œ ë–¨ì–´ì§„ ê²ƒì„ ì´ì–´ì„œ ê°€ì ¸ì˜¤ë ¤ë©´ LW/SWë¥¼ 2ë²ˆ ì¨ì•¼í•¨.  
  
ex) 7 6 5 4  
  
```  
  3 2 1 0  
```  
  
ì˜ ìˆœìœ¼ë¡œ ë˜ì–´ìˆì„ë•Œ, 4-3-2-1 ì„ ê°€ì ¸ì˜¤ê³ ì‹¶ë‹¤.  
  
LWL rd 3(r0)  
  
LWR rd 6(r0)  
  
ì„ ê°ê° í•´ì•¼í•œë‹¤. â†’ Alignmentê°€ ê°•ìš”ëœë‹¤. (MIPS ë“±, ì¸í…” ë¨¸ì‹ ì€ ì•„ë¬´ë°ì„œë‚˜ ê°€ëŠ¥)  
  
### 3. Store Instructions  
  
Assembly: SW rt offset(base)  
  
Machine code:  
  
`SW (base 5-bit) (rt 5-bit) offset (16-bit)`  
  
â†’ ì¦‰, ì–´ëŠ í•œ ì£¼ì†Œì—ì„œ 2^16 ì´ìƒ ë„˜ì–´ê°€ëŠ”ê²Œ ë¶ˆê°€ëŠ¥í•˜ë‹¤. ì´ëŠ” ë’¤ì—ì„œ ì„¤ëª…!  
  
ì´ë•Œ, offset(16-bit)ê³¼ baseì˜ ê°’ (32-bit)ë¥¼ sign-extenstoní•œë‹¤.  
  
### Load Delay Slots  
  
```nasm  
LW ra --  
addi r- ra r-  
addi r- ra r-  
```  
  
LWê°€ ì •ë§ ì˜¤ë˜ê±¸ë¦´ ê²ƒ ê°™ìœ¼ë‹ˆâ€¦ ì„±ëŠ¥ì€ í•˜ë“œì›¨ì–´ì˜ ì˜ì—­ì¸ë° í”„ë¡œê·¸ë˜ë¨¸ê°€ ì´ë ‡ê²Œ ì§œë²„ë ¸ë‹¤.  
  
### 4. Branch Insturctions  
  
Assembly: BEQ rs rt immediate  
  
Machine code  
  
`BEQ (6-bit) rs rt immediate(16-bit)` (I-type)  
  
if GPR[rs] === GPR[rt], PC â† PC + target  
  
else, PC â† PC +4  
  
<aside> ğŸ’¡  
  
How far can you jump?  
  
â†’ 2^(16)ì¸ë°, ì–´ì°¨í”¼ ë§ˆì§€ë§‰ ëª…ë ¹ì–´ëŠ” 00ìœ¼ë¡œ align ë˜ì–´ ìˆë‹¤. ë”°ë¼ì„œ ë’¤ì— 2ê°œë¥¼ ì œì™¸í•˜ê³  ì´ 2^18ê°œê¹Œì§€ ê°ˆ ìˆ˜ ìˆìœ¼ë©°, ìŒìˆ˜ë¥¼ ê³ ë ¤í•˜ë©´ -2^17 ~ 2^17ê¹Œì§€ ê°€ëŠ¥í•˜ë‹¤.  
  
</aside>  
  
<aside> ğŸ’¡  
  
Why there isnâ€™t a BLT or BGT?  
  
â†’ Zeroì™€ ë¹„êµí•˜ëŠ”ê²Œ í› ì–¼ì”¬ ë¹ ë¦„. ëº€ ê°’ì´ 0ì¸ì§€ë§Œ ë°”ë¡œ ë³´ë©´ ë˜ê±°ë“ .  
  
</aside>  
  
### 5. Jump Instruction  
  
Assembly: J immediate (26)  
  
Machine code  
  
`J (6-bit) immediate (26-bit)`  
  
target = {PC[31:28], immediate}  
  
ì¦‰, PCì˜ ì• 4ë¹„íŠ¸ë¥¼ ì½ëŠ”ë‹¤ëŠ” ê²ƒì€, ì „ì²´ 4GB ë©”ëª¨ë¦¬ ì˜ì—­ì„ 16ë“±ë¶„í•œ ë’¤, í•´ë‹¹ blockì—ì„œë§Œ ì›€ì§ì´ê² ë‹¤ëŠ” ê²ƒìœ¼ë¡œ ì´í•´í•´ë„ ì¢‹ë‹¤. ë”°ë¼ì„œ, ë‚´ ê³µê°„ì˜ ì²«ìë¦¬ ë‚´ë¶€ì—ì„œ ì´ë™ì´ ê°€ëŠ¥í•˜ë‹¤.  
  
---  
  
### Branch Delay Slots  
  
- branch instructionì€ architectural latencyê°€ 1ë§Œí¼ ì¡´ì¬í•œë‹¤.  
  
â†’ ê·¸ë˜ì„œ ì˜›ë‚ ì—ëŠ” nopì„ ë„£ì–´ì¤˜ì„œ ì»´íŒŒì¼ëŸ¬ê°€ ì´ë ‡ê²Œ í•´ë²„ë¦°ë‹¤.  
  
```nasm  
bne r1 r2 L1  
  
add r3 r4 r0  
j L2  
  
...  
```  
  
```nasm  
bne r1 r2 L1  
j L2  
add r3 r4 r0  
```  
  
branch ì¡°ê±´ì´ ë§Œì¡±í•˜ëŠ”ì§€ ì²´í¬í•  ë•Œ ê¹Œì§€ nop ìœ¼ë¡œ ì±„ì›Œë²„ë¦°ë‹¤. â†’ pipe-liningì˜ ì„±ëŠ¥ ìµœì í™”ë¥¼ ìœ„í•¨.  
  
independentí•œ ëª…ë ¹ì–´ê°€ ìˆê¸° ë•Œë¬¸ì— ìˆœì„œë¥¼ ë°”ê¿”ë²„ë¦°ë‹¤.  
  
â†’ ì•„í‚¤í…ì³ ìœ„ë°°  
  
---  
  
## Function Call and Return  
  
### Jump and Link  
  
- JAL offset (26-bit)  
  
â†’ ê·¸ ë‹¤ìŒì— ì‹¤í–‰í•  ëª…ë ¹ì–´ ì£¼ì†Œë¥¼ r31ì— ì €ì¥í•˜ê³  jumpí•œë‹¤.  
  
### Jump Indirect  
  
JR rs_reg  
  
- ì•„ë¬´ë°ë‚˜ register ì£¼ì†Œì— ìˆëŠ” ê°’ ìœ„ì¹˜ë¡œ ì í”„í•œë‹¤.  
  
â†’ usually used by r31 (function return)  
  
---  
  
### Caller-save Callee-save  
  
- Caller-saved register.  
    - í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ë©° ë“¤ì–´ê°€ê¸° ì „ì— stackì— register ìƒí™©ì„ ëª¨ë‘ ì €ì¥í•˜ê³  rsp ëŠ˜ë¦¬ê³  rbp ì˜®ê¸°ê³ ë¥¼ í•œë‹¤.  
    - r31  
- Callee-saved register  
    - jumpí•œ í›„ ì“°ê¸° ì „ì—, register ìƒíƒœ ì €ì¥. ë‚˜ê°€ê¸° ì „ì— ë³µêµ¬í•˜ê³  return  
  
---  
  
## Calling convention  
  
1. Caler saves caller-saved register  
2. caller loads arguments into r4~r7 â†’ í•¨ìˆ˜ argument  
3. caller jumps to callee using JAL (callí•˜ë©´ì„œ r31ì— ë‹¤ìŒ ëª…ë ¹ì–´ë¥¼ ì§‘ì–´ë„£ìŒ.)  
  
â€”prologueâ€”-  
  
1. Callee allocates space on stack (rbpê°’ì— rspì˜®ê¸°ê³  rspê°’ ì¤„ì´ê¸°)  
2. Callee saves callee-saved registers to stack (r4~r7, old rbp, r31 â†’ callee save)  
  
<aside> ğŸ’¡  
  
Why? old rbp â†’ stack í¬ê¸° ì–¼ë§ˆë‚˜ ì¤„ì¼ì§€ íŒë‹¨, r31 ì—¬ëŸ¬ë²ˆ depthë¡œ ë¶ˆë¦´ê±¸ ê°ì•ˆí•¨.  
  
</aside>  
  
--epilogueâ€”  
  
1. Callee loads results to r2, r3  
2. Callee restores callee-saved registers  
3. JR r31  
  
â€”  
  
1. Caller restores caller-saved  
2. caller continues with return value r2, r3 (x86ì—ì„œëŠ” raxâ€¦ì˜€ë˜ê±¸ë¡œ ê¸°ì–µ)